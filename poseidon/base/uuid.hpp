// This file is part of Poseidon.
// Copyleft 2022 - 2023, LH_Mouse. All wrongs reserved.

#ifndef POSEIDON_BASE_UUID_
#define POSEIDON_BASE_UUID_

#include "../fwd.hpp"
namespace poseidon {

class uuid
  {
  public:
    // Fields of this structure are named according to RFC 4122 and have no
    // actual meaning. Multi-byte fields are stored in the host (native) byte
    // order.
    // Reference: https://datatracker.ietf.org/doc/html/rfc4122
    struct fields
      {
        uint32_t time_low;
        uint16_t time_mid;
        uint16_t time_hi_and_version;
        uint64_t clk_seq_res : 16;
        uint64_t node : 48;
      };

    // This is a special tag type to select the random UUID constructor.
    struct random
      {
      };

  private:
    union {
      uint8_t m_bytes[16] = { };
      __m128i m_stor;

      struct {
        uint8_t m_data_1_3;
        uint8_t m_data_1_2;
        uint8_t m_data_1_1;
        uint8_t m_data_1_0;
        uint8_t m_data_2_1;
        uint8_t m_data_2_0;
        uint8_t m_data_3_1;
        uint8_t m_data_3_0;
        uint8_t m_data_4_1;
        uint8_t m_data_4_0;
        uint8_t m_data_5_5;
        uint8_t m_data_5_4;
        uint8_t m_data_5_3;
        uint8_t m_data_5_2;
        uint8_t m_data_5_1;
        uint8_t m_data_5_0;
      };
    };

  public:
    // Constructs a nil UUID.
    constexpr
    uuid() noexcept = default;

    // Constructs a UUID in the RFC 4122 format.
    constexpr
    uuid(const fields& fs) noexcept
      {
        this->m_data_1_3 = (uint8_t) (fs.time_low >> 24);
        this->m_data_1_2 = (uint8_t) (fs.time_low >> 16);
        this->m_data_1_1 = (uint8_t) (fs.time_low >>  8);
        this->m_data_1_0 = (uint8_t)  fs.time_low;
        this->m_data_2_1 = (uint8_t) (fs.time_mid >> 8);
        this->m_data_2_0 = (uint8_t)  fs.time_mid;
        this->m_data_3_1 = (uint8_t) (fs.time_hi_and_version >> 8);
        this->m_data_3_0 = (uint8_t)  fs.time_hi_and_version;
        this->m_data_4_1 = (uint8_t) (fs.clk_seq_res >> 8);
        this->m_data_4_0 = (uint8_t)  fs.clk_seq_res;
        this->m_data_5_5 = (uint8_t) (fs.node >> 40);
        this->m_data_5_4 = (uint8_t) (fs.node >> 32);
        this->m_data_5_3 = (uint8_t) (fs.node >> 24);
        this->m_data_5_2 = (uint8_t) (fs.node >> 16);
        this->m_data_5_1 = (uint8_t) (fs.node >>  8);
        this->m_data_5_0 = (uint8_t)  fs.node;
      }

    // Generates a random UUID `xxxxxxxx-xxxx-Myyy-Nzzz-zzzzzzzzzzzz`, where:
    //
    //   * `x` is the number of 1/30518 seconds since UNIX Epoch, and
    //   * `M` is always `4` (UUID version 4), and
    //   * `y` is the current process ID, and
    //   * `N` is either `6` or `7` (UUID variant 3), and
    //   * `z` is random bytes.
    //
    // All numbers are written in big-endian order, so all UUIDs that have
    // been generated by this function are sorted in their order of creation.
    // This function shall be cryptographically secure. An exception is thrown
    // if the system entropy source fails.
    __attribute__((__leaf__))
    uuid(const random&);

    // Parses a UUID from a string, like `parse()`.
    // An exception is thrown if the UUID string is not valid.
    explicit
    uuid(const char* str, size_t len);

    explicit
    uuid(const char* str);

    explicit
    uuid(cow_stringR str);

    uuid&
    swap(uuid& other) noexcept
      {
        ::std::swap(this->m_stor, other.m_stor);
        return *this;
      }

  public:
    // Gets raw bytes.
    constexpr
    const uint8_t*
    data() const noexcept
      { return this->m_bytes;  }

    uint8_t*
    mut_data() noexcept
      { return this->m_bytes;  }

    constexpr
    size_t
    size() const noexcept
      { return 16;  }

    constexpr
    const uint8_t*
    begin() const noexcept
      { return this->m_bytes;  }

    constexpr
    const uint8_t*
    end() const noexcept
      { return this->m_bytes + 16;  }

    uint8_t*
    mut_begin() noexcept
      { return this->m_bytes;  }

    uint8_t*
    mut_end() noexcept
      { return this->m_bytes + 16;  }

    // Checks whether this UUID is the nil UUID.
    ROCKET_PURE operator
    bool() const noexcept
      {
        __m128i tval = _mm_load_si128(&(this->m_stor));
        __m128i oval = _mm_setzero_si128();
        int cmp = _mm_movemask_epi8(_mm_cmpeq_epi8(tval, oval));  // bits := 0xFFFF if equal
        return cmp == 0xFFFF;
      }

    // Peforms three-way comparison.
    ROCKET_PURE
    bool
    equals(const uuid& other) const noexcept
      {
        __m128i tval = _mm_load_si128(&(this->m_stor));
        __m128i oval = _mm_load_si128(&(other.m_stor));
        int cmp = _mm_movemask_epi8(_mm_cmpeq_epi8(tval, oval));  // bits := 0xFFFF if equal
        return cmp == 0xFFFF;
      }

    ROCKET_PURE
    int
    compare(const uuid& other) const noexcept;

    // Parses a UUID from a string in the RFC 4122 format. An example is
    // `f81d4fae-7dec-11d0-a765-00a0c91e6bf6`. If a UUID has been parsed, the
    // number of characters that have been consumed is returned, which is
    // always 36; otherwise zero is returned, and the contents of this object
    // are unspecified.
    size_t
    parse_partial(const char* str) noexcept;

    size_t
    parse(const char* str, size_t len) noexcept;

    // Converts this UUID to its RFC 4112 form. Hexadecimal digits are written
    // in uppercase. The caller should supply a buffer for 37 characters. A
    // null terminator will always be appended. The number of characters that
    // have been written is stored, which is always 36.
    size_t
    print_partial(char* str) const noexcept;

    tinyfmt&
    print(tinyfmt& fmt) const;

    cow_string
    print_to_string() const;
  };

extern const uuid uuid_nil;  // 00000000-0000-0000-0000-000000000000
extern const uuid uuid_max;  // FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF

inline
void
swap(uuid& lhs, uuid& rhs) noexcept
  {
    lhs.swap(rhs);
  }

inline
tinyfmt&
operator<<(tinyfmt& fmt, const uuid& value)
  {
    return value.print(fmt);
  }

inline
bool
operator==(const uuid& lhs, const uuid& rhs) noexcept
  {
    return lhs.equals(rhs) == true;
  }

inline
bool
operator!=(const uuid& lhs, const uuid& rhs) noexcept
  {
    return lhs.equals(rhs) != true;
  }

inline
bool
operator<(const uuid& lhs, const uuid& rhs) noexcept
  {
    return lhs.compare(rhs) < 0;
  }

inline
bool
operator>(const uuid& lhs, const uuid& rhs) noexcept
  {
    return lhs.compare(rhs) > 0;
  }

inline
bool
operator<=(const uuid& lhs, const uuid& rhs) noexcept
  {
    return lhs.compare(rhs) <= 0;
  }

inline
bool
operator>=(const uuid& lhs, const uuid& rhs) noexcept
  {
    return lhs.compare(rhs) >= 0;
  }

}  // namespace poseidon
#endif
