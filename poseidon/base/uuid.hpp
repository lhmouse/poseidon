// This file is part of Poseidon.
// Copyleft 2022 - 2024, LH_Mouse. All wrongs reserved.

#ifndef POSEIDON_BASE_UUID_
#define POSEIDON_BASE_UUID_

#include "../fwd.hpp"
#include <uuid/uuid.h>
namespace poseidon {

class UUID
  {
  private:
    union {
      ::uuid_t m_uuid = { };  // array
      __m128i m_stor;
    };

  public:
    // Constructs an all-zero UUID.
    constexpr UUID() noexcept = default;

    // Parses a UUID from a string, like `parse()`.
    // An exception is thrown if the UUID string is not valid.
    UUID(chars_view str);

    UUID&
    swap(UUID& other) noexcept
      {
        ::std::swap(this->m_stor, other.m_stor);
        return *this;
      }

  public:
    // Returns a static all-zero UUID.
    static ROCKET_CONST
    const UUID&
    min() noexcept;

    // Returns a static all-one UUID.
    static ROCKET_CONST
    const UUID&
    max() noexcept;

    // Generates a random UUID `xxxxxxxx-xxxx-Myyy-Nzzz-zzzzzzzzzzzz`, where:
    //
    //   * `x` is the number of 1/30518 seconds since 2001-03-01T00:00:00Z, and
    //   * `M` is always `4` (UUID version 4), and
    //   * `y` is the current process ID, and
    //   * `N` is either `6` or `7` (UUID variant 3), and
    //   * `z` is random bytes.
    //
    // All numbers are written in big-endian order, so all UUIDs that have
    // been generated by this function are sorted in their order of creation.
    // This function shall be cryptographically secure.
    static
    UUID
    random() noexcept;

    // Get raw bytes.
    constexpr
    const uint8_t*
    data() const noexcept
      { return this->m_uuid;  }

    constexpr
    size_t
    size() const noexcept
      { return 16;  }

    constexpr
    const uint8_t*
    begin() const noexcept
      { return this->m_uuid;  }

    constexpr
    const uint8_t*
    end() const noexcept
      { return this->m_uuid + 16;  }

    // Checks whether this UUID is the nil UUID.
    ROCKET_PURE
    bool
    is_nil() const noexcept
      {
        __m128i tval = _mm_load_si128(&(this->m_stor));
        __m128i oval = _mm_setzero_si128();
        int eq_mask = _mm_movemask_epi8(_mm_cmpeq_epi8(tval, oval));
        return eq_mask == 0xFFFF;
      }

    // Performs three-way comparison.
    ROCKET_PURE
    bool
    equals(const UUID& other) const noexcept
      {
        __m128i tval = _mm_load_si128(&(this->m_stor));
        __m128i oval = _mm_load_si128(&(other.m_stor));

        int eq_mask = _mm_movemask_epi8(_mm_cmpeq_epi8(tval, oval));
        return eq_mask == 0xFFFF;
      }

    ROCKET_PURE
    int
    compare(const UUID& other) const noexcept
      {
        __m128i tval = _mm_load_si128(&(this->m_stor));
        __m128i oval = _mm_load_si128(&(other.m_stor));

        __m128i bits_rev = _mm_set_epi8(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);
        __m128i bits_to_u8 = _mm_set1_epi8(-0x80);
        tval = _mm_xor_si128(_mm_shuffle_epi8(tval, bits_rev), bits_to_u8);
        oval = _mm_xor_si128(_mm_shuffle_epi8(oval, bits_rev), bits_to_u8);

        int gt_mask = _mm_movemask_epi8(_mm_cmpgt_epi8(tval, oval));
        int lt_mask = _mm_movemask_epi8(_mm_cmpgt_epi8(oval, tval));
        return gt_mask - lt_mask;
      }

    // Tries parsing a UUID from a string in the RFC 4122 format. An example is
    // `f81d4fae-7dec-11d0-a765-00a0c91e6bf6`. If a UUID has been parsed, the number
    // of characters that have been consumed is returned, which is always 36;
    // otherwise zero is returned, and the contents of this object are unspecified.
    size_t
    parse_partial(const char* str) noexcept;

    // Tries parsing a UUID from a string like `parse_partial()`, but the length of
    // `str` is validated.
    size_t
    parse(chars_view str) noexcept;

    // Converts this UUID to its RFC 4112 form. Hexadecimal digits are written in
    // uppercase. The caller should supply a buffer for 37 characters. A null
    // terminator is always appended. The number of characters that have been written
    // is stored, which is always 36.
    size_t
    print_partial(char* str) const noexcept;

    tinyfmt&
    print_to(tinyfmt& fmt) const;

    cow_string
    print_to_string() const;
  };

inline
void
swap(UUID& lhs, UUID& rhs) noexcept
  { lhs.swap(rhs);  }

inline
tinyfmt&
operator<<(tinyfmt& fmt, const UUID& value)
  { return value.print_to(fmt);  }

inline
bool
operator==(const UUID& lhs, const UUID& rhs) noexcept
  { return lhs.equals(rhs) != false;  }

inline
bool
operator!=(const UUID& lhs, const UUID& rhs) noexcept
  { return lhs.equals(rhs) == false;  }

inline
bool
operator<(const UUID& lhs, const UUID& rhs) noexcept
  { return lhs.compare(rhs) < 0;  }

inline
bool
operator>(const UUID& lhs, const UUID& rhs) noexcept
  { return lhs.compare(rhs) > 0;  }

inline
bool
operator<=(const UUID& lhs, const UUID& rhs) noexcept
  { return lhs.compare(rhs) <= 0;  }

inline
bool
operator>=(const UUID& lhs, const UUID& rhs) noexcept
  { return lhs.compare(rhs) >= 0;  }

}  // namespace poseidon
#endif
