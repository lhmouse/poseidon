// This file is part of Poseidon.
// Copyright (C) 2022-2025, LH_Mouse. All wrongs reserved.

#ifndef POSEIDON_BASE_UUID_
#define POSEIDON_BASE_UUID_

#include "../fwd.hpp"
namespace poseidon {

class UUID
  {
  public:
    struct hash;

    struct fields
      {
        uint32_t xh;
        uint16_t xl;
        uint16_t y;
        uint64_t zh : 16;
        uint64_t zl : 48;
      };

  private:
    union {
      ::std::array<uint8_t, 16> m_bytes = { };
      __m128i m_stor;
      uint64_t m_quads[2];
    };

  public:
    // Constructs an all-zero UUID.
    constexpr
    UUID() noexcept = default;

    // Constructs a UUID from individual fields.
    constexpr
    UUID(const fields& f) noexcept
      {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#pragma GCC diagnostic ignored "-Wsign-conversion"
        this->m_bytes[0] = f.xh >> 24;
        this->m_bytes[1] = f.xh >> 16;
        this->m_bytes[2] = f.xh >> 8;
        this->m_bytes[3] = f.xh;
        this->m_bytes[4] = f.xl >> 8;
        this->m_bytes[5] = f.xl;
        this->m_bytes[6] = f.y >> 8;
        this->m_bytes[7] = f.y;
        this->m_bytes[8] = f.zh >> 8;
        this->m_bytes[9] = f.zh;
        this->m_bytes[10] = f.zl >> 40;
        this->m_bytes[11] = f.zl >> 32;
        this->m_bytes[12] = f.zl >> 24;
        this->m_bytes[13] = f.zl >> 16;
        this->m_bytes[14] = f.zl >> 8;
        this->m_bytes[15] = f.zl;
#pragma GCC diagnostic pop
      }

    // Constructs a UUID from an `std::array`.
    constexpr
    UUID(const ::std::array<uint8_t, 16>& bytes) noexcept
      : m_bytes(bytes)  { }

    // Parses a UUID from a string, like `parse()`.
    // An exception is thrown if the UUID string is not valid.
    UUID(chars_view str);

    UUID&
    swap(UUID& other) noexcept
      {
        ::std::swap(this->m_stor, other.m_stor);
        return *this;
      }

  public:
    // Returns a static all-zero UUID.
    static ROCKET_CONST
    const UUID&
    min() noexcept;

    // Returns a static all-one UUID.
    static ROCKET_CONST
    const UUID&
    max() noexcept;

    // Generates a random UUID `xxxxxxxx-xxxx-Myyy-Nzzz-zzzzzzzzzzzz`, where:
    //
    // * `x` is the number of 1/30518 seconds since 2001-03-01T00:00:00Z, and
    // * `M` is always `4` (UUID version 4), and
    // * `y` is the current process ID, and
    // * `N` is `0` through `7`, and
    // * `z` is random bytes.
    //
    // All numbers are written in big-endian order, so all UUIDs that have
    // been generated by this function are sorted in their order of creation.
    // This function shall be cryptographically secure.
    static
    UUID
    random() noexcept;

    // Get raw bytes.
    constexpr
    const ::std::array<uint8_t, 16>&
    as_array() const noexcept
      { return this->m_bytes;  }

    constexpr
    const uint8_t*
    data() const noexcept
      { return this->m_bytes.data();  }

    constexpr
    size_t
    size() const noexcept
      { return 16;  }

    constexpr
    const uint8_t*
    begin() const noexcept
      { return this->m_bytes.begin();  }

    constexpr
    const uint8_t*
    end() const noexcept
      { return this->m_bytes.end();  }

    ROCKET_PURE
    bool
    is_nil() const noexcept
      {
        __m128i tval = _mm_load_si128(&(this->m_stor));
        __m128i oval = _mm_setzero_si128();
        return _mm_movemask_epi8(_mm_cmpeq_epi8(tval, oval)) == 0xFFFF;
      }

    ROCKET_PURE
    bool
    equals(const UUID& other) const noexcept
      {
        __m128i tval = _mm_load_si128(&(this->m_stor));
        __m128i oval = _mm_load_si128(&(other.m_stor));
        return _mm_movemask_epi8(_mm_cmpeq_epi8(tval, oval)) == 0xFFFF;
      }

    ROCKET_PURE
    int
    compare(const UUID& other) const noexcept;

    // Tries parsing a UUID from a string in the RFC 4122 format. An example is
    // `f81d4fae-7dec-11d0-a765-00a0c91e6bf6`. If a UUID has been parsed, the number
    // of characters that have been consumed is returned, which is always 36;
    // otherwise zero is returned, and the contents of this object are unspecified.
    size_t
    parse_partial(const char* str) noexcept;

    // Tries parsing a UUID from a string like `parse_partial()`, but the length of
    // `str` is validated.
    size_t
    parse(chars_view str) noexcept;

    // Converts this UUID to its RFC 4112 form. Hexadecimal digits are written in
    // uppercase. The caller should supply a buffer for 37 characters. A null
    // terminator is always appended. The number of characters that have been written
    // is stored, which is always 36.
    size_t
    print_partial(char* str) const noexcept;

    tinyfmt&
    print_to(tinyfmt& fmt) const;

    cow_string
    to_string() const;
  };

struct UUID::hash
  {
    using result_type    = size_t;
    using argument_type  = UUID;

    result_type
    operator()(const UUID& uuid) const noexcept
      {
        __m128i tval = _mm_load_si128(&(uuid.m_stor));
        tval = _mm_hadd_epi32(tval, _mm_bsrli_si128(tval, 8));
        tval = _mm_hadd_epi32(tval, tval);
        return static_cast<size_t>(_mm_cvtsi128_si64(tval));
      }
  };

#define POSEIDON_UUID(a8,b4,c4,d4,e12)  \
    (::poseidon::UUID(::poseidon::UUID::fields { 0x##a8,0x##b4,0x##c4,0x##d4,0x##e12 }))

inline
void
swap(UUID& lhs, UUID& rhs) noexcept
  { lhs.swap(rhs);  }

inline
tinyfmt&
operator<<(tinyfmt& fmt, const UUID& value)
  { return value.print_to(fmt);  }

inline
bool
operator==(const UUID& lhs, const UUID& rhs) noexcept
  { return lhs.equals(rhs) != false;  }

inline
bool
operator!=(const UUID& lhs, const UUID& rhs) noexcept
  { return lhs.equals(rhs) == false;  }

inline
bool
operator<(const UUID& lhs, const UUID& rhs) noexcept
  { return lhs.compare(rhs) < 0;  }

inline
bool
operator>(const UUID& lhs, const UUID& rhs) noexcept
  { return lhs.compare(rhs) > 0;  }

inline
bool
operator<=(const UUID& lhs, const UUID& rhs) noexcept
  { return lhs.compare(rhs) <= 0;  }

inline
bool
operator>=(const UUID& lhs, const UUID& rhs) noexcept
  { return lhs.compare(rhs) >= 0;  }

}  // namespace poseidon
#endif
