// This file is part of Poseidon.
// Copyleft 2022 - 2024, LH_Mouse. All wrongs reserved.

#ifndef POSEIDON_MYSQL_MYSQL_CONNECTION_
#define POSEIDON_MYSQL_MYSQL_CONNECTION_

#include "../fwd.hpp"
#include "../third/mysql_fwd.hpp"
namespace poseidon {

class MySQL_Connection
  {
  private:
    friend class MySQL_Connector;

    cow_string m_server;
    cow_string m_user;
    cow_string m_passwd;
    cow_string m_db;
    uint16_t m_port;
    bool m_connected;
    bool m_reset_clear;

    mysql_Client m_mysql;
    uniptr_MYSQL_STMT m_stmt;
    uniptr_MYSQL_RES m_meta;
    uniptr_MYSQL_RES m_res;

  public:
    // Sets connection parameters. This function does not attempt to connect
    // to the server, and is not blocking.
    MySQL_Connection(cow_stringR server, uint16_t port, cow_stringR user, cow_stringR passwd, cow_stringR db);

  private:
    ::MYSQL_FIELD*
    do_metadata_for_field_opt(unsigned col) noexcept;

  public:
    MySQL_Connection(const MySQL_Connection&) = delete;
    MySQL_Connection& operator=(const MySQL_Connection&) & = delete;
    ~MySQL_Connection();

    // Get connection parameters.
    cow_stringR
    server() const noexcept
      { return this->m_server;  }

    cow_stringR
    user() const noexcept
      { return this->m_user;  }

    cow_stringR
    db() const noexcept
      { return this->m_db;  }

    uint16_t
    port() const noexcept
      { return this->m_port;  }

    // Resets the connection so it can be reused by another thread. This is a
    // blocking functions. DO NOT ATTEMPT TO REUSE THE CONNECTION IF THIS
    // FUNCTION RETURNS `false`.
    // Returns whether the connection may be safely reused.
    bool
    reset() noexcept;

    // Executes a query. `stmt` shall be a SQL statement with placeholders, like
    // `INSERT INTO test_table(col1,col2,col3) VALUES(?,?,?)"`. `args` supplies
    // values for those placeholders. If a connection to the server has not been
    // established yet, this function initiates a new connection before the query
    // is executed.
    void
    execute(cow_stringR stmt, const MySQL_Value* args_opt, size_t nargs);

    void
    execute(cow_stringR stmt, const vector<MySQL_Value>& args);

    void
    execute(cow_stringR stmt);

    // Fetches the names of all fields of the result set. This function must be
    // called after `execute()`. `output` is cleared before fetching any data. If
    // the query has produced a result and all fields have been successfully
    // fetched, `true` is returned. If there is no result, `false` is returned.
    bool
    fetch_fields(vector<cow_string>& output);

    // Fetches a row of the result from the previous query. This function must be
    // called after `execute()`. `output` is cleared before fetching any data. If
    // the query has produced a result and a row has been successfully fetched,
    // `true` is returned. If there is no result or the end of result has been
    // reached, `false` is returned.
    bool
    fetch_row(vector<MySQL_Value>& output);

    // Gets the number of rows that have been affected. This function must be
    // called after `execute()`.
    uint64_t
    affected_rows() const;

    // Gets the auto-increment id that is generated by the last statement. This
    // function must be called after `execute()`.
    uint64_t
    insert_id() const;
  };

}  // namespace poseidon
#endif
